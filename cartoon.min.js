function draw(cxt,lineWidth,linejoin,borderColor,fillColor){
    cxt.strokeStyle = borderColor || '';
    cxt.lineWidth = lineWidth || 1;
    cxt.linejoin = linejoin || 'round'; 
    cxt.fillStyle = fillColor || "";
    cxt.fill();
    cxt.stroke();
}
function drawLine(mycanvas,x1,y1,x2,y2){
    var cxt = mycanvas.getContext('2d');
    cxt.moveTo(x1,y1);
    cxt.lineTo(x2,y2);
    draw(cxt,0.5,'round','#ccc');
}
//画矩形
function drawRect(mycanvas,x,y,width,height){
    var cxt = mycanvas.getContext('2d');
    cxt.beginPath();
    cxt.rect(x,y,width,height);
    draw(cxt,8,'round','light-blue','orange');
}
function drawRect2(mycanvas,x,y,width,height,lineWidth,linejoin,borderColor,fillColor){
    var cxt = mycanvas.getContext('2d');
    cxt.beginPath();
    cxt.strokeStyle = borderColor || '#eee';
    cxt.lineWidth = lineWidth || 1;
    cxt.lineJoin = linejoin || 'round';
    cxt.fillStyle = fillColor || "#000";
    cxt.strokeRect(x,y,width,height);
    cxt.fillRect(x,y,width,height);
}
//五角星路径
function drawStar(mycanvas,x,y,r,R,rot=0){
    var cxt = mycanvas.getContext('2d');
    cxt.beginPath();
    for(var i=0;i<5;++i){
        cxt.lineTo(x+Math.cos((18+rot+72*i)/180*Math.PI)*R,y-Math.sin((18+rot+72*i)/180*Math.PI)*R);
        cxt.lineTo(x+Math.cos((54+rot+72*i)/180*Math.PI)*r,y-Math.sin((54+rot+72*i)/180*Math.PI)*r);
    }
    cxt.closePath();
    draw(cxt,4,'round','#03b','orange');
}
function getNewmycanvas(){
    var backmycanvas = document.createElement('mycanvas');
    backmycanvas.width = 50;
    backmycanvas.height = 50;
    var bcxt = backmycanvas.getContext('2d');
    drawStar(bcxt,25,25,10,20,3);
    return backmycanvas;
}
//圆角矩形
function roundRectPath(cxt,width,height,radius){	
    var tempH = height - 2*radius;
    var tempW = width - 2*radius;
    cxt.arc(tempW,tempH,radius,0,Math.PI*0.5);
    cxt.lineTo(0,tempH+radius);
    cxt.arc(0,tempH,radius,0.5*Math.PI,Math.PI);
    cxt.lineTo(-radius,0);
    cxt.arc(0,0,radius,Math.PI,Math.PI*3/2);
    cxt.lineTo(tempW,-radius);
    cxt.arc(tempW,0,radius,Math.PI*3/2,Math.PI*2);
    cxt.closePath();
}
function drawRoundRect(mycanvas,x,y,width,height,radius,lineWidth,linejoin,borderColor,fillColor){
    var cxt = mycanvas.getContext('2d');
    if(2*radius > width || 2*radius > height) return;
    cxt.beginPath();
    cxt.translate(x,y);
    roundRectPath(cxt,width,height,radius);
    draw(cxt,lineWidth,linejoin,borderColor,fillColor);
}
function drawArcTo(mycanvas,x0,y0,x1,y1,x2,y2,radius,lineWidth,linejoin,borderColor){
    var cxt = mycanvas.getContext('2d');
    cxt.beginPath();
    cxt.moveTo(x0,y0);
    cxt.arcTo(x1,y1,x2,y2,radius);
    draw(cxt,lineWidth,linejoin,borderColor);
}
function moonPath(cxt,d){//d表示月亮弯曲程度[0,1]
    cxt.beginPath();
    cxt.arc(0,0,1,0.5*Math.PI,1.5*Math.PI,true);
    cxt.arcTo(d,0,0,1,dist(0,-1,d,0)/d);
    cxt.closePath();
}
function moonPath2(cxt,d){//d表示月亮弯曲程度[0,1]
    cxt.beginPath();
    cxt.arc(0,0,1,0.5*Math.PI,1.5*Math.PI,true);
    cxt.quadraticCurveTo(d,0,0,1);
    cxt.closePath();
}
//月亮
function drawMoon(mycanvas,x,y,d,r,rot,lineWidth,linejoin,borderColor,fillColor){
    var cxt = mycanvas.getContext('2d');
    cxt.save();
    cxt.translate(x,y);
    cxt.scale(r,r);
    cxt.rotate(rot*Math.PI/180);
    moonPath2(cxt,d);
    cxt.restore();
    draw(cxt,lineWidth,linejoin,borderColor,fillColor);
}
function drawLand(mycanvas,lineWidth,linejoin,borderColor,fillColor){
    var cxt = mycanvas.getContext('2d');
    cxt.save();
    cxt.beginPath();
    cxt.moveTo(0,500);
    cxt.bezierCurveTo(230,400,510,580,800,470);
    cxt.lineTo(800,600);
    cxt.lineTo(0,600);
    cxt.closePath();
    cxt.restore();
    var landstyle = cxt.createLinearGradient(0,420,800,600);
    landstyle.addColorStop(0,'#030');
    landstyle.addColorStop(1,'#580');
    draw(cxt,lineWidth,linejoin,borderColor,landstyle);
}
function dist(x1,y1,x2,y2){
    return Math.sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}
//随机运动小球
function drawRandomCircles(mycanvas,num){
    var cxt = mycanvas.getContext('2d'),
        balls = [],
        mycanvasW = mycanvas.width,mycanvasH = mycanvas.height;
    cxt.globalAlpha = 0.6;
    cxt.globalCompositeOperation = 'xor';
    for(var j=0;j<num;j++){
        var R = Math.floor(Math.random()*255),
         G = Math.floor(Math.random()*255),
         B = Math.floor(Math.random()*255),
         aBall = {
            radius: Math.random()*2+3,
            x: Math.random()*mycanvasW,
            y: Math.random()*mycanvasH,
            color: "rgb("+R+","+G+','+B+')',
            Vx: Math.random()*2+0.5,
            Vy: Math.random()*2+0.5
         };
        balls[j] = aBall;
    }
    //mycanvas.addEventListener('click',detect);
    setInterval(function(){
        drawBalls(mycanvas,balls);
        updateBalls(mycanvas,balls);
    },45);
}
function updateBalls(mycanvas,objArrary){	
    var len = objArrary.length; 
    for(var i=0;i<len;i++){//检测碰撞
        objArrary[i].x += objArrary[i].Vx;
        objArrary[i].y += objArrary[i].Vy;
        if(objArrary[i].x- objArrary[i].radius<0){
            objArrary[i].Vx = -objArrary[i].Vx;
            objArrary[i].x = objArrary[i].radius;
        }
        if(objArrary[i].y - objArrary[i].radius<0){
            objArrary[i].Vy = -objArrary[i].Vy;
            objArrary[i].y = objArrary[i].radius;
        }
        if(objArrary[i].x + objArrary[i].radius>mycanvas.width){
            objArrary[i].Vx = -objArrary[i].Vx;
            objArrary[i].x = mycanvas.width - objArrary[i].radius;
        }
        if(objArrary[i].y + objArrary[i].radius>mycanvas.height){
            objArrary[i].Vy = -objArrary[i].Vy;
            objArrary[i].y = mycanvas.height - objArrary[i].radius;
        }
    }
}
function drawBalls(mycanvas,objArrary){
    var len = objArrary.length,
    cxt = mycanvas.getContext('2d');
    cxt.clearRect(0,0,mycanvas.width,mycanvas.height);  
    for(var i=0;i<len;i++){
        cxt.save();
        cxt.fillStyle = objArrary[i].color;
        cxt.beginPath();	
        cxt.arc(objArrary[i].x,objArrary[i].y,objArrary[i].radius,0,Math.PI*2);
        cxt.fill();	
        cxt.restore();
        for(var k=0;k!=i;k++){
            if(dist(objArrary[k].x,objArrary[k].y,objArrary[i].x,objArrary[i].y)<80){
                drawLine(mycanvas,objArrary[k].x,objArrary[k].y,objArrary[i].x,objArrary[i].y);
            }
        }	
    }   
}
// function detect(mycanvas,event){
// 	var cxt = mycanvas.getContext('2d');
// 	var x = event.clientX - mycanvas.getBoundingClientRect().left;//
// 	var y = event.clientY - mycanvas.getBoundingClientRect().top;//获取点击坐标
// 	if(cxt.isPointInPath(x,y)){//交互
// 		cxt.fill();
// 	}//判断是否在点击区域
// }
//探照灯
function searchLight(mycanvas,light){
    var cxt = mycanvas.getContext('2d'),
    mycanvasW = mycanvas.width,
    mycanvasH = mycanvas.height;
    cxt.clearRect(0,0,mycanvasW,mycanvasH);
    cxt.save();
    cxt.beginPath();
    cxt.fillStyle = "black";
    cxt.fillRect(0,0,mycanvasW,mycanvasH);

    cxt.beginPath();
    cxt.arc(light.x,light.y,light.radius,0,Math.PI*2);
    cxt.fillStyle = "#fff";
    cxt.fill();
    cxt.clip();

    cxt.font = "bold 50px Arial";
    cxt.fillStyle = "#058";
    cxt.fillText('hello cartoon.js!',mycanvasW/3,mycanvasW/2);
    cxt.restore();
}
function updateLight(mycanvas,light){
    light.x += light.Vx;
    light.y += light.Vy;
    //碰撞检测
    if(light.x - light.radius<0){
        light.Vx = -light.Vx;
        light.x = light.radius;
    }if(light.y - light.radius<0){
        light.Vy = -light.Vy;
        light.y = light.radius;
    }if(light.x + light.radius>mycanvas.width){
        light.Vx = -light.Vx;
        light.x = mycanvas.width - light.radius;
    }if(light.y + light.radius>mycanvas.height){
        light.Vy = -light.Vy;
        light.y = mycanvas.height - light.radius;
    }
}
function drawSearchLight(mycanvas,light){
    var tick = setInterval(function(){
        updateLight(mycanvas,light);
        searchLight(mycanvas,light);
    },40);
}
//星空
function drawStarSky(){
    var can,ctx,canW,canH,
    girl = new Image(),
    star = new Image(),
    //定义星星对象
    starObj = function(){
        this.x;
        this.y;
        this.frame;
        this.gap;
    },
    num = 50,
    stars = [],
    gapTime,lastTime;
    starObj.prototype.init = function(){
        this.x = Math.random()*(canW-25);
        this.y = Math.random()*(canH-80);
        this.frame = Math.floor(Math.random()*7);
        this.gap = 0;
    }
    starObj.prototype.anime = function(){
        this.gap += gapTime;
        if(this.gap > 120) {
            this.frame += 1;
            this.frame %= 7;
            this.gap = 0;
        }
    }
    starObj.prototype.drawStar = function(){
        ctx.drawImage(star,this.frame*7,0,7,7,this.x,this.y,7,7);
    }
    function init(){
        can = document.getElementById('mycanvas');
        ctx = can.getContext('2d');
        canW = can.width;
        canH = can.height;
        girl.src = 'src/girl.jpg';
        star.src = 'src/star.png';
        for(var i=0;i<num;i++){
            var obj = new starObj();
            obj.init();
            stars.push(obj);
        }
        lastTime = Date.now();
        frameLoop();
        /*setInterval(function(){
            frameLoop();
        },250);*/
    }
    function frameLoop(){
        window.requestAnimationFrame(frameLoop);
        var now = Date.now();
        gapTime = now - lastTime;//两帧之间的时间
        lastTime = now;
        drawBackgroud();
        drawStars();
    }
    function drawBackgroud(){
        ctx.fillStyle ='black';
        ctx.fillRect(0,0,canW,canH);
    }
    //处理序列帧图片
    function drawObj(obj,sx,sy,sWidth,sHeight,x,y,width,height){
        ctx.drawImage(obj,x,y,width,height);
    }
    function drawStars(){
        for(var i=0;i<num;++i){
            stars[i].anime();
            stars[i].drawStar();	
        }
    }	
    init();
}
function drawRiver(mycanvas,lineWidth,linejoin,borderColor,fillColor){
    var cxt = mycanvas.getContext('2d'),
        mycanvasH = mycanvas.height,
        riverH = mycanvasH;
    cxt.clearRect(0,0,mycanvas.width,mycanvas.height);
    var tick = setInterval(function(){
        riverH -= 10; 
        riverFlowing(mycanvas,riverH,lineWidth,linejoin,borderColor,fillColor);
    },50);
}
function riverFlowing(mycanvas,riverH,lineWidth,linejoin,borderColor,fillColor){
    var cxt = mycanvas.getContext('2d'),
    mycanvasW = mycanvas.width,
    mycanvasH = mycanvas.height,
    riverW = parseInt(mycanvasW/3);
    cxt.save();
    cxt.beginPath();
    cxt.moveTo(0,riverH*0.8);
    cxt.bezierCurveTo(mycanvasW+Math.random()*20,riverH-Math.random()*80,mycanvasW*2+Math.random()*20,riverH+Math.random()*200,mycanvasW*3+Math.random()*80,riverH+Math.random()*120);
    cxt.lineTo(mycanvasW,mycanvasH);
    cxt.lineTo(0,mycanvasH);
    cxt.closePath();
    cxt.restore();
    var landstyle = cxt.createLinearGradient(0,riverH,mycanvasW,mycanvasH);
    landstyle.addColorStop(0,'#07f');
    landstyle.addColorStop(1,'#04f');
    draw(cxt,lineWidth,linejoin,'#07f',landstyle);
}
//连线动画
var cartoon = {};
function linkTo(mycanvas,x1,y1,x2,y2,speed){
    var ctx = mycanvas.getContext('2d');
        ctx.beginPath(); 
        ctx.moveTo(x1,y1);
    var k = (y2-y1)/(x2-x1);    
    var tick = setInterval(function(){
        console.log(x1,x2);
        if(k>0){
            if(x1 < x2){
                ctx.lineTo(x1+=speed,y1+=k*speed);
            }else{
                ctx.lineTo(x1-=speed,y1-=k*speed);
            }
        }else{
            if(x1 < x2){
                ctx.lineTo(x1+=speed,y1+=k*speed);
            }else{
                ctx.lineTo(x1-=speed,y1-=k*speed);
            }
        }
        ctx.stroke();
        if(x1 === x2){
            clearInterval(tick);
        }         
    },50);
}
function drawParticle(mycanvas,num){
    var ctx = mycanvas.getContext('2d'),
    balls = [],
    _Ball = {
                radius: 20,
                x: Math.random()*mycanvas.width,
                y: Math.random()*mycanvas.height,
                // color: ,
                Vx: Math.random()*2+0.5,
                Vy: Math.random()*2+0.5
    };
    ctx.beginPath();
    ctx.fillStyle = 'yellow';
    ctx.arc(_Ball.x,_Ball.y,_Ball.radius,0,Math.PI*2);
    ctx.fill();
    for(var i =0;i<num;++i){
        aBall = {
                radius: Math.random()*2+1,
                x: Math.random()*30-init_Ball.x-init_Ball.radius,
                y: Math.random()*30+init_Ball.y,
                color: 'yellow',
                Vx: Math.random()*2+0.5,
                Vy: Math.random()*2+0.5
        };
        balls[i] = aBall;
    }
    setInterval(function(){
        drawParticles(mycanvas,balls);
        updateParticles(mycanvas,balls);
    },45);
}
function drawParticles(mycanvas,objArrary){
    var len = objArrary.length,
    cxt = mycanvas.getContext('2d');
    cxt.clearRect(0,0,mycanvas.width,mycanvas.height);  
    for(var i=0;i<len;i++){
        cxt.save();
        cxt.fillStyle = objArrary[i].color;
        cxt.beginPath();	
        cxt.arc(objArrary[i].x,objArrary[i].y,objArrary[i].radius,0,Math.PI*2);
        cxt.fill();	
        cxt.restore();
    }   
}
function updateParticles(mycanvas,objArrary){	
    var len = objArrary.length; 
    for(var i=0;i<len;i++){//检测碰撞
        objArrary[i].x += objArrary[i].Vx;
        objArrary[i].y += objArrary[i].Vy;
        if(objArrary[i].x- objArrary[i].radius<0){
            objArrary[i].Vx = -objArrary[i].Vx;
            objArrary[i].x = objArrary[i].radius;
        }
        if(objArrary[i].y - objArrary[i].radius<0){
            objArrary[i].Vy = -objArrary[i].Vy;
            objArrary[i].y = objArrary[i].radius;
        }
        if(objArrary[i].x + objArrary[i].radius>mycanvas.width){
            objArrary[i].Vx = -objArrary[i].Vx;
            objArrary[i].x = mycanvas.width - objArrary[i].radius;
        }
        if(objArrary[i].y + objArrary[i].radius>mycanvas.height){
            objArrary[i].Vy = -objArrary[i].Vy;
            objArrary[i].y = mycanvas.height - objArrary[i].radius;
        }
    }
}